# Comparing `tmp/rqdatac-3.0.4-cp39-cp39-win_amd64.whl.zip` & `tmp/rqdatac-3.0.5-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,54 +1,54 @@
-Zip file size: 301169 bytes, number of entries: 52
+Zip file size: 300331 bytes, number of entries: 52
 -rw-rw-rw-  2.0 fat      967 b- defN 23-Dec-01 07:07 rqdatac/__init__.py
 -rw-rw-rw-  2.0 fat    10668 b- defN 24-Mar-29 02:50 rqdatac/__init__.pyi
 -rw-rw-rw-  2.0 fat      934 b- defN 23-Dec-01 07:07 rqdatac/_internal.py
--rw-rw-rw-  2.0 fat      518 b- defN 24-Apr-16 06:16 rqdatac/_version.py
+-rw-rw-rw-  2.0 fat      518 b- defN 24-Apr-29 07:16 rqdatac/_version.py
 -rw-rw-rw-  2.0 fat    10387 b- defN 23-Dec-22 06:50 rqdatac/client.py
--rw-rw-rw-  2.0 fat   138752 b- defN 24-Apr-16 06:16 rqdatac/connection.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   760728 b- defN 24-Apr-16 06:15 rqdatac/connection.cpp
+-rw-rw-rw-  2.0 fat   138752 b- defN 24-Apr-29 07:16 rqdatac/connection.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat   760728 b- defN 24-Apr-29 07:15 rqdatac/connection.cpp
 -rw-rw-rw-  2.0 fat     2239 b- defN 23-Dec-01 07:07 rqdatac/connection_pool.py
 -rw-rw-rw-  2.0 fat     4447 b- defN 23-Dec-01 07:07 rqdatac/decorators.py
 -rw-rw-rw-  2.0 fat     3072 b- defN 23-Dec-01 07:07 rqdatac/rqdatah_helper.py
 -rw-rw-rw-  2.0 fat     2140 b- defN 23-Dec-01 07:07 rqdatac/thread_local.py
--rw-rw-rw-  2.0 fat     8727 b- defN 23-Dec-01 07:07 rqdatac/utils.py
+-rw-rw-rw-  2.0 fat    10929 b- defN 24-Apr-29 06:08 rqdatac/utils.py
 -rw-rw-rw-  2.0 fat     9265 b- defN 24-Jan-12 06:37 rqdatac/validators.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-01 07:07 rqdatac/services/__init__.py
 -rw-rw-rw-  2.0 fat     6792 b- defN 23-Dec-01 07:07 rqdatac/services/async_live_md_client.py
 -rw-rw-rw-  2.0 fat    74860 b- defN 24-Mar-26 06:33 rqdatac/services/basic.py
 -rw-rw-rw-  2.0 fat     6202 b- defN 23-Dec-01 07:07 rqdatac/services/calendar.py
 -rw-rw-rw-  2.0 fat     2470 b- defN 23-Dec-01 07:07 rqdatac/services/concept.py
 -rw-rw-rw-  2.0 fat    47501 b- defN 24-Apr-16 06:15 rqdatac/services/consensus.py
 -rw-rw-rw-  2.0 fat    10141 b- defN 23-Dec-01 07:07 rqdatac/services/constant.py
 -rw-rw-rw-  2.0 fat    29339 b- defN 24-Mar-29 02:50 rqdatac/services/convertible.py
 -rw-rw-rw-  2.0 fat     2405 b- defN 23-Dec-01 07:07 rqdatac/services/extra.py
 -rw-rw-rw-  2.0 fat    33958 b- defN 24-Mar-29 02:50 rqdatac/services/factor.py
--rw-rw-rw-  2.0 fat    12600 b- defN 24-Mar-29 02:50 rqdatac/services/financial.py
+-rw-rw-rw-  2.0 fat    12561 b- defN 24-Apr-29 06:08 rqdatac/services/financial.py
 -rw-rw-rw-  2.0 fat    33768 b- defN 24-Apr-16 06:15 rqdatac/services/future.py
--rw-rw-rw-  2.0 fat    15558 b- defN 23-Dec-01 07:07 rqdatac/services/get_capital_flow.py
+-rw-rw-rw-  2.0 fat    13532 b- defN 24-Apr-29 06:08 rqdatac/services/get_capital_flow.py
 -rw-rw-rw-  2.0 fat    29756 b- defN 24-Mar-15 05:59 rqdatac/services/get_price.py
 -rw-rw-rw-  2.0 fat     8880 b- defN 24-Mar-15 05:59 rqdatac/services/index.py
--rw-rw-rw-  2.0 fat     8488 b- defN 23-Dec-01 07:07 rqdatac/services/ksh_auction_info.py
+-rw-rw-rw-  2.0 fat     6473 b- defN 24-Apr-29 06:08 rqdatac/services/ksh_auction_info.py
 -rw-rw-rw-  2.0 fat    15816 b- defN 23-Dec-01 07:07 rqdatac/services/live.py
 -rw-rw-rw-  2.0 fat    17180 b- defN 23-Dec-01 07:07 rqdatac/services/live_md_client.py
 -rw-rw-rw-  2.0 fat    18853 b- defN 24-Apr-16 06:15 rqdatac/services/market_data.py
--rw-rw-rw-  2.0 fat    11873 b- defN 24-Mar-15 05:59 rqdatac/services/options.py
+-rw-rw-rw-  2.0 fat    12650 b- defN 24-Apr-29 06:08 rqdatac/services/options.py
 -rw-rw-rw-  2.0 fat     9995 b- defN 23-Dec-01 07:07 rqdatac/services/shenwan.py
 -rw-rw-rw-  2.0 fat    29976 b- defN 24-Feb-23 09:49 rqdatac/services/stock_status.py
 -rw-rw-rw-  2.0 fat     2310 b- defN 23-Dec-01 07:07 rqdatac/services/structured_fund.py
 -rw-rw-rw-  2.0 fat     2268 b- defN 23-Dec-01 07:07 rqdatac/services/tmall.py
 -rw-rw-rw-  2.0 fat     3649 b- defN 23-Dec-01 07:07 rqdatac/services/xueqiu.py
 -rw-rw-rw-  2.0 fat       61 b- defN 23-Dec-01 07:07 rqdatac/services/detail/__init__.py
 -rw-rw-rw-  2.0 fat     5733 b- defN 23-Dec-01 07:07 rqdatac/services/detail/adjust_price.py
--rw-rw-rw-  2.0 fat    15968 b- defN 23-Dec-01 07:07 rqdatac/services/detail/get_price_df.py
+-rw-rw-rw-  2.0 fat    14077 b- defN 24-Apr-29 06:08 rqdatac/services/detail/get_price_df.py
 -rw-rw-rw-  2.0 fat     1833 b- defN 23-Dec-01 07:07 rqdatac/services/detail/resample_helper.py
 -rw-rw-rw-  2.0 fat       16 b- defN 23-Dec-01 07:07 rqdatac/services/orm/__init__.py
 -rw-rw-rw-  2.0 fat    12814 b- defN 23-Dec-01 07:07 rqdatac/services/orm/pit_financials_ex.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-01 07:07 rqdatac/share/__init__.py
 -rw-rw-rw-  2.0 fat     5289 b- defN 23-Dec-01 07:07 rqdatac/share/codec.py
 -rw-rw-rw-  2.0 fat     1728 b- defN 23-Dec-01 07:07 rqdatac/share/errors.py
 -rw-rw-rw-  2.0 fat     1817 b- defN 23-Dec-01 07:07 rqdatac/share/protocol.py
--rw-rw-rw-  2.0 fat     2540 b- defN 24-Apr-16 06:16 rqdatac-3.0.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-16 06:16 rqdatac-3.0.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 24-Apr-16 06:16 rqdatac-3.0.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     4381 b- defN 24-Apr-16 06:16 rqdatac-3.0.4.dist-info/RECORD
-52 files, 1439770 bytes uncompressed, 294263 bytes compressed:  79.6%
+-rw-rw-rw-  2.0 fat     2517 b- defN 24-Apr-29 07:16 rqdatac-3.0.5.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-29 07:16 rqdatac-3.0.5.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 24-Apr-29 07:16 rqdatac-3.0.5.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     4382 b- defN 24-Apr-29 07:16 rqdatac-3.0.5.dist-info/RECORD
+52 files, 1436756 bytes uncompressed, 293425 bytes compressed:  79.6%
```

## zipnote {}

```diff
@@ -138,20 +138,20 @@
 
 Filename: rqdatac/share/errors.py
 Comment: 
 
 Filename: rqdatac/share/protocol.py
 Comment: 
 
-Filename: rqdatac-3.0.4.dist-info/METADATA
+Filename: rqdatac-3.0.5.dist-info/METADATA
 Comment: 
 
-Filename: rqdatac-3.0.4.dist-info/WHEEL
+Filename: rqdatac-3.0.5.dist-info/WHEEL
 Comment: 
 
-Filename: rqdatac-3.0.4.dist-info/top_level.txt
+Filename: rqdatac-3.0.5.dist-info/top_level.txt
 Comment: 
 
-Filename: rqdatac-3.0.4.dist-info/RECORD
+Filename: rqdatac-3.0.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## rqdatac/_version.py

```diff
@@ -4,18 +4,18 @@
 # unpacked source archive. Distribution tarballs contain a pre-generated copy
 # of this file.
 
 import json
 
 version_json = '''
 {
- "date": "2024-04-16T10:49:39+0800",
+ "date": "2024-04-29T11:07:39+0800",
  "dirty": false,
  "error": null,
- "full-revisionid": "493a77a1d58ea2a7865881dc9948663f302e3522",
- "version": "3.0.4"
+ "full-revisionid": "1a66a75cddeb2307596c5134cf115855450b645a",
+ "version": "3.0.5"
 }
 '''  # END VERSION_JSON
 
 
 def get_versions():
     return json.loads(version_json)
```

## rqdatac/utils.py

```diff
@@ -289,8 +289,68 @@
             key += "_vol"
         t = tick.get(key)
         if t:
             return t[int(field[1]) - 1]
         else:
             return default
     else:
-        return tick.get(field, default)
+        return tick.get(field, default)
+
+
+def convert_bar_to_multi_df(data, dt_name, fields, convert_dt, default=np.nan, return_slice_map=False):
+    line_no = 0
+    dt_set = set()
+    obid_level = []
+    obid_slice_map = {}
+    for obid, d in data:
+        dts = d[dt_name]
+        dts_len = len(dts)
+        if dts_len == 0:
+            continue
+        obid_slice_map[obid] = slice(line_no, line_no + dts_len, None)
+        dt_set.update(dts)
+        line_no += dts_len
+
+        obid_level.append(obid)
+
+    if line_no == 0:
+        return (None, obid_slice_map) if return_slice_map else None
+
+    obid_idx_map = {o: i for i, o in enumerate(obid_level)}
+    obid_label = np.empty(line_no, dtype=object)
+    dt_label = np.empty(line_no, dtype=object)
+    arr = np.full((line_no, len(fields)), default)
+    r_map_fields = {f: i for i, f in enumerate(fields)}
+
+    dt_arr_sorted = np.array(sorted(dt_set))
+    dt_level = convert_dt(dt_arr_sorted)
+
+    for obid, d in data:
+        dts = d[dt_name]
+        if len(dts) == 0:
+            continue
+        slice_ = obid_slice_map[obid]
+        for f, value in d.items():
+            if f == dt_name:
+                dt_label[slice_] = dt_arr_sorted.searchsorted(dts, side='left')
+            else:
+                arr[slice_, r_map_fields[f]] = value
+        obid_label[slice_] = [obid_idx_map[obid]] * len(dts)
+    try:
+        # func 'is_datetime_with_singletz_array'  is the most time consuming part in multi_index constructing
+        # it is useless for our situation. skip it.
+        func_is_singletz = getattr(pd._libs.lib, 'is_datetime_with_singletz_array')
+        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', lambda *args: True)
+    except AttributeError:
+        func_is_singletz = None
+
+    multi_idx = pd.MultiIndex([obid_level, dt_level], [obid_label, dt_label],
+                              names=('order_book_id', dt_name))
+
+    if func_is_singletz is not None:
+        # recovery
+        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', func_is_singletz)
+
+    df = pd.DataFrame(data=arr, index=multi_idx, columns=fields)
+    if return_slice_map:
+        return df, obid_slice_map
+    return df
```

## rqdatac/services/financial.py

```diff
@@ -215,16 +215,15 @@
 
     data = get_client().execute(
         "current_performance", order_book_id, info_date, end_date, fields, market=market
     )
     if not data:
         return
     df = pd.DataFrame(data)
-    sort_field = "info_date" if info_date else "end_date"
-    df.sort_values(by=[sort_field, "mark"], ascending=[False, True], inplace=True)
+    df.sort_values(by=["end_date", "info_date", "mark"], ascending=[False, False, True], inplace=True)
     df.drop_duplicates(subset="end_date", keep="first", inplace=True)
     num = int(interval[:-1])
     unit = interval[-1]
     if unit == "y":
         latest_month = df.iloc[0]["end_date"].month
         df["month"] = df.end_date.apply(lambda x: x.month)
         df = df[df.month == latest_month]
```

## rqdatac/services/get_capital_flow.py

```diff
@@ -17,109 +17,52 @@
 from rqdatac.utils import (
     int8_to_datetime_v,
     int14_to_datetime_v,
     int17_to_datetime_v,
     int17_to_datetime,
     date_to_int8,
     get_tick_value,
+    convert_bar_to_multi_df,
 )
 from rqdatac.client import get_client
 from rqdatac.decorators import export_as_api
 from rqdatac.share.errors import PermissionDenied, MarketNotSupportError
 
 
 DAYBAR_FIELDS = MINBAR_FIELDS = ["buy_volume", "buy_value", "sell_volume", "sell_value"]
 TICKBAR_FIELDS = ["datetime", "direction", "volume", "value"]
 
 
-def convert_bar_to_multi_df(data, dt_name, fields, convert_dt, default=0.0):
-    line_no = 0
-    dt_set = set()
-    obid_level = []
-    obid_slice_map = {}
-    for obid, d in data:
-        dts = d[dt_name]
-        dts_len = len(dts)
-        if dts_len == 0:
-            continue
-        obid_slice_map[obid] = slice(line_no, line_no + dts_len, None)
-        dt_set.update(dts)
-        line_no += dts_len
-
-        obid_level.append(obid)
-
-    if line_no == 0:
-        return
-
-    obid_idx_map = {o: i for i, o in enumerate(obid_level)}
-    obid_label = np.empty(line_no, dtype=object)
-    dt_label = np.empty(line_no, dtype=object)
-    arr = np.full((line_no, len(fields)), default)
-    r_map_fields = {f: i for i, f in enumerate(fields)}
-
-    dt_arr_sorted = np.array(sorted(dt_set))
-    dt_level = convert_dt(dt_arr_sorted)
-
-    for obid, d in data:
-        dts = d[dt_name]
-        if len(dts) == 0:
-            continue
-        slice_ = obid_slice_map[obid]
-        for f, value in d.items():
-            if f == dt_name:
-                dt_label[slice_] = dt_arr_sorted.searchsorted(dts, side='left')
-            else:
-                arr[slice_, r_map_fields[f]] = value
-        obid_label[slice_] = [obid_idx_map[obid]] * len(dts)
-    try:
-        # func 'is_datetime_with_singletz_array'  is the most time consuming part in multi_index constructing
-        # it is useless for our situation. skip it.
-        func_is_singletz = getattr(pd._libs.lib, 'is_datetime_with_singletz_array')
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', lambda *args: True)
-    except AttributeError:
-        func_is_singletz = None
-
-    multi_idx = pd.MultiIndex([obid_level, dt_level], [obid_label, dt_label],
-                              names=('order_book_id', dt_name))
-
-    if func_is_singletz is not None:
-        # recovery
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', func_is_singletz)
-
-    df = pd.DataFrame(data=arr, index=multi_idx, columns=fields)
-    return df
-
-
 def get_capital_flow_daybar(order_book_ids, start_date, end_date, fields, duration=1, market="cn"):
     data = get_client().execute(
         "get_capital_flow_daybar", order_book_ids, start_date, end_date, fields, duration, market=market
     )
     data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
-    res = convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v)
+    res = convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v, 0.)
     return res
 
 
 def get_today_capital_flow_minbar(order_book_ids, date, fields, duration, market="cn"):
     data = get_client().execute("get_today_capital_flow_minbar", order_book_ids, date, fields, duration, market=market)
-    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v)
+    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v, 0.)
 
 
 def get_capital_flow_minbar(order_book_ids, start_date, end_date, fields, duration, market):
     history_permission_denied = realtime_permission_denied = False
     try:
         data = get_client().execute(
             "get_capital_flow_minbar", order_book_ids, start_date, end_date, fields, duration, market=market
         )
     except PermissionDenied:
         history_permission_denied = True
         data = []
 
     if data:
         data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
-        df = convert_bar_to_multi_df(data, 'datetime', fields, int14_to_datetime_v)
+        df = convert_bar_to_multi_df(data, 'datetime', fields, int14_to_datetime_v, 0.)
     else:
         df = None
 
     live_date = current_trading_date()
     if start_date > live_date or end_date < live_date:
         return df
 
@@ -347,15 +290,15 @@
     if data:
         data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
 
         extra_fields = ['open_interest', 'prev_settlement', 'date'] if any(
             ['prev_settlement' in d for _, d in data]
         ) else ['date']
 
-        df = convert_bar_to_multi_df(data, 'datetime', fields + extra_fields, int17_to_datetime_v, default=0.0)
+        df = convert_bar_to_multi_df(data, 'datetime', fields + extra_fields, int17_to_datetime_v, 0.)
         if df is not None:
             del df["date"]
     else:
         df = None
 
     if start_date > live_date or end_date < live_date:
         return df
```

## rqdatac/services/ksh_auction_info.py

```diff
@@ -16,85 +16,28 @@
 from rqdatac.utils import (
     int8_to_datetime_v,
     int14_to_datetime_v,
     int17_to_datetime_v,
     int17_to_datetime,
     today_int,
     date_to_int8,
+    convert_bar_to_multi_df,
 )
 from rqdatac.client import get_client
 from rqdatac.decorators import export_as_api
 from rqdatac.share.errors import MarketNotSupportError, PermissionDenied
 
 DAYBAR_FIELDS = [
     "close", "volume", "total_turnover"
 ]
 TICKBAR_FIELDS = [
     "datetime", "close", "volume", "total_turnover", "bid_vol", "ask_vol"
 ]
 
 
-def convert_bar_to_multi_df(data, dt_name, fields, convert_dt):
-    line_no = 0
-    dt_set = set()
-    obid_level = []
-    obid_slice_map = {}
-    for obid, d in data:
-        dts = d[dt_name]
-        dts_len = len(dts)
-        if dts_len == 0:
-            continue
-        obid_slice_map[obid] = slice(line_no, line_no + dts_len, None)
-        dt_set.update(dts)
-        line_no += dts_len
-
-        obid_level.append(obid)
-
-    if line_no == 0:
-        return
-
-    obid_idx_map = {o: i for i, o in enumerate(obid_level)}
-    obid_label = np.empty(line_no, dtype=object)
-    dt_label = np.empty(line_no, dtype=object)
-    arr = np.full((line_no, len(fields)), np.nan)
-    r_map_fields = {f: i for i, f in enumerate(fields)}
-
-    dt_arr_sorted = np.array(sorted(dt_set))
-    dt_level = convert_dt(dt_arr_sorted)
-
-    for obid, d in data:
-        dts = d[dt_name]
-        if len(dts) == 0:
-            continue
-        slice_ = obid_slice_map[obid]
-        for f, value in d.items():
-            if f == dt_name:
-                dt_label[slice_] = dt_arr_sorted.searchsorted(dts, side='left')
-            else:
-                arr[slice_, r_map_fields[f]] = value
-        obid_label[slice_] = [obid_idx_map[obid]] * len(dts)
-    try:
-        # func 'is_datetime_with_singletz_array'  is the most time consuming part in multi_index constructing
-        # it is useless for our situation. skip it.
-        func_is_singletz = getattr(pd._libs.lib, 'is_datetime_with_singletz_array')
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', lambda *args: True)
-    except AttributeError:
-        func_is_singletz = None
-
-    multi_idx = pd.MultiIndex([obid_level, dt_level], [obid_label, dt_label],
-                              names=('order_book_id', dt_name))
-
-    if func_is_singletz is not None:
-        # recovery
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', func_is_singletz)
-
-    df = pd.DataFrame(data=arr, index=multi_idx, columns=fields)
-    return df
-
-
 def get_auction_info_daybar(order_book_ids, start_date, end_date, fields, duration=1, market="cn"):
     data = get_client().execute(
         "get_auction_info_daybar", order_book_ids, start_date, end_date, fields, duration, market
     )
     data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
     res = convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v)
     return res
```

## rqdatac/services/options.py

```diff
@@ -1,10 +1,11 @@
 # -*- coding: utf-8 -*-
 import datetime
 
+import numpy as np
 import pandas as pd
 
 from rqdatac.validators import (
     check_items_in_container,
     ensure_date_int,
     ensure_order_book_ids,
     ensure_string,
@@ -14,35 +15,39 @@
 )
 
 from rqdatac import get_trading_dates
 from rqdatac.client import get_client
 from rqdatac.decorators import export_as_api
 from rqdatac.services.basic import all_instruments, instruments
 from rqdatac.services.get_price import get_price
-from rqdatac.utils import is_panel_removed
+from rqdatac.utils import is_panel_removed, convert_bar_to_multi_df, int14_to_datetime_v
 from rqdatac.rqdatah_helper import rqdatah_serialize, http_conv_list_to_csv
 
 VALID_GREEKS_FIELDS = ['iv', 'delta', 'gamma', 'vega', 'theta', 'rho']
 
 
 @export_as_api(namespace='options')
-def get_greeks(order_book_ids, start_date=None, end_date=None, fields=None, model='implied_forward', price_type='close', market="cn"):
+def get_greeks(order_book_ids, start_date=None, end_date=None, fields=None, model='implied_forward', price_type='close', frequency='1d', market="cn"):
     """获取指定股票期权的隐含波动率iv， 以及5个希腊字母数值(delta, gamma, bega, theta, rho)
     :param order_book_ids: 股票 order_book_id or order_book_id list
     :param start_date: 开始日期, 必要参数
     :param end_date: 结束日期；默认为今天
     :param fields: str或list类型. 默认为None, 返回所有fields.
     :param model: str类型， last: 代表用每日close价格， implied_forward 代表用隐含风险收益率计算
     :param price_type: 'close' or 'settlement'
+    :param frequency: '1d' or '1m', 如果为'1m'，则price_type必须为'close'
     :param market: 默认值为"cn"
     """
 
     order_book_ids = ensure_order_book_ids(order_book_ids, market=market)
     check_items_in_container(model, ['implied_forward', 'last'], 'model')
     ensure_string_in(price_type, ('close', 'settlement'), 'price_type')
+    ensure_string_in(frequency, ('1d', '1m'), 'frequency')
+    if frequency == '1m' and price_type != 'close':
+        raise ValueError('1m frequency only support price_type=close!')
     if start_date is not None:
         start_date = ensure_date_int(start_date)
     else:
         raise ValueError('start_date is expected')
     if end_date is not None:
         end_date = ensure_date_int(end_date)
     else:
@@ -52,20 +57,29 @@
 
     if fields is None:
         fields = VALID_GREEKS_FIELDS
     else:
         fields = ensure_list_of_string(fields, 'fields')
         check_items_in_container(fields, VALID_GREEKS_FIELDS, 'Greeks')
 
-    data = get_client().execute("options.get_greeks", order_book_ids, start_date, end_date, fields, model, price_type, market=market)
+    if frequency == '1m':
+        data = get_client().execute('options.get_greeks_min', order_book_ids, start_date, end_date, fields, model, market=market)
+    else:
+        data = get_client().execute("options.get_greeks", order_book_ids, start_date, end_date, fields, model, price_type, market=market)
     if not data:
         return None
 
+    if frequency == '1m':
+        data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
+        df = convert_bar_to_multi_df(data, 'datetime', fields, int14_to_datetime_v)
+        return df
+
     df = pd.DataFrame(data)
-    df.set_index(["order_book_id", "trading_date"], inplace=True)
+    date_field = 'trading_date'
+    df.set_index(["order_book_id", date_field], inplace=True)
     df.sort_index(inplace=True)
     return df[fields]
 
 
 SPECIAL_UNDERLYING_SYMBOL = ("510050.XSHG", "510300.XSHG", "159919.XSHE")
```

## rqdatac/services/detail/get_price_df.py

```diff
@@ -8,14 +8,15 @@
 from rqdatac.services.get_price import _ensure_fields
 
 from rqdatac.services.calendar import is_trading_date, current_trading_date, get_next_trading_date
 from rqdatac.utils import (
     int14_to_datetime_v,
     int8_to_datetime_v,
     date_to_int8,
+    convert_bar_to_multi_df,
 )
 from rqdatac.client import get_client
 from rqdatac.services.future import get_dominant, current_real_contract
 from rqdatac.services.basic import instruments
 from rqdatac.services.stock_status import is_suspended
 from rqdatac.share.errors import PermissionDenied, MarketNotSupportError, NoSuchService
 
@@ -240,33 +241,33 @@
 
 
 def get_daybar(order_book_ids, start_date, end_date, fields, duration, market):
     data = get_client().execute(
         "get_daybar_v", order_book_ids, start_date, end_date, fields, duration, market
     )
     data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
-    return convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v)
+    return convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v, return_slice_map=True)
 
 
 def get_future_indx_daybar(order_book_ids, start_date, end_date, fields, duration=1, market="cn"):
     data = get_client().execute(
         "futures.get_future_indx_daybar_v", order_book_ids, start_date, end_date, fields, duration, market
     )
     data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
-    multi_df, _ = convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v)
+    multi_df, _ = convert_bar_to_multi_df(data, 'date', fields, int8_to_datetime_v, return_slice_map=True)
     if multi_df is not None:
         return multi_df
 
 
 def get_minbar(order_book_ids, start_date, end_date, fields, duration, market):
     data = get_client().execute(
         "get_minbar_v", order_book_ids, start_date, end_date, fields, duration, market
     )
     data = [(obid, {k: np.frombuffer(*v) for k, v in d.items()}) for obid, d in data]
-    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v)
+    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v, return_slice_map=True)
 
 
 def get_today_minbar(order_book_ids, fields, duration, market="cn"):
     futures_88 = [i for i in instruments(order_book_ids) if i.order_book_id.endswith('88') and i.type == 'Future']
     real_contracts = {
         i.order_book_id: current_real_contract(i.underlying_symbol, market)
         for i in futures_88
@@ -274,75 +275,15 @@
     real_contracts = {k: v for k, v in real_contracts.items() if v is not None}
     order_book_ids = set(order_book_ids)
     obs = list(order_book_ids.union(set(real_contracts.values())))
     data = get_client().execute("get_today_minbar", obs, fields, duration, market)
     data = dict(data)
     data.update((ob, data.get(c)) for ob, c in real_contracts.items())
     data = [(k, v) for k, v in data.items() if k in order_book_ids]
-    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v)
-
-
-def convert_bar_to_multi_df(data, dt_name, fields, convert_dt):
-    line_no = 0
-    dt_set = set()
-    obid_level = []
-    obid_slice_map = {}
-    for obid, d in data:
-        dts = d[dt_name]
-        dts_len = len(dts)
-        if dts_len == 0:
-            continue
-        obid_slice_map[obid] = slice(line_no, line_no + dts_len, None)
-        dt_set.update(dts)
-        line_no += dts_len
-
-        obid_level.append(obid)
-
-    if line_no == 0:
-        return None, obid_slice_map
-
-    obid_idx_map = {o: i for i, o in enumerate(obid_level)}
-    obid_label = np.empty(line_no, dtype=object)
-    dt_label = np.empty(line_no, dtype=object)
-    arr = np.full((line_no, len(fields)), np.nan)
-    r_map_fields = {f: i for i, f in enumerate(fields)}
-    for f in ZERO_FILL_FIELDS:
-        if f in fields:
-            arr[:, r_map_fields[f]] = 0
-
-    dt_arr_sorted = np.array(sorted(dt_set), dtype=np.int64)
-    dt_level = convert_dt(dt_arr_sorted)
-
-    for obid, d in data:
-        dts = d[dt_name]
-        if len(dts) == 0:
-            continue
-        slice_ = obid_slice_map[obid]
-        for f, value in d.items():
-            if f == dt_name:
-                dt_label[slice_] = dt_arr_sorted.searchsorted(dts, side='left')
-            else:
-                arr[slice_, r_map_fields[f]] = value
-        obid_label[slice_] = [obid_idx_map[obid]] * len(dts)
-
-    try:
-        func_is_singletz = getattr(pd._libs.lib, 'is_datetime_with_singletz_array')
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', lambda *args: True)
-    except AttributeError:
-        func_is_singletz = None
-    multi_idx = pd.MultiIndex(
-        [obid_level, dt_level],
-        [obid_label, dt_label],
-        names=('order_book_id', dt_name)
-    )
-    if func_is_singletz is not None:
-        setattr(pd._libs.lib, 'is_datetime_with_singletz_array', func_is_singletz)
-
-    df = pd.DataFrame(data=arr, index=multi_idx, columns=fields)
-    return df, obid_slice_map
+    return convert_bar_to_multi_df(data, "datetime", fields, int14_to_datetime_v, return_slice_map=True)
 
 
 def _adjust_pf(
         pf,
         order_book_ids,
         stocks,
         funds,
```

## Comparing `rqdatac-3.0.4.dist-info/METADATA` & `rqdatac-3.0.5.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: rqdatac
-Version: 3.0.4
+Version: 3.0.5
 Summary: Ricequant Data SDK
 Home-page: https://www.ricequant.com/doc/rqdata-institutional#research-version
 Author: Ricequant
 Author-email: public@ricequant.com
 License: UNKNOWN
 Download-URL: https://pypi.org/
 Platform: UNKNOWN
@@ -22,15 +22,14 @@
 Classifier: Environment :: Console
 Description-Content-Type: text/markdown
 Requires-Dist: brotli
 Requires-Dist: python-dateutil
 Requires-Dist: msgpack (>=0.5.2)
 Requires-Dist: six
 Requires-Dist: orjson
-Requires-Dist: pymysql
 Requires-Dist: python-rapidjson
 Requires-Dist: zstandard ; os_name != "nt" and python_version > "2.7"
 Requires-Dist: win-inet-pton ; os_name == "nt"
 Requires-Dist: pandas (!=2.1.*) ; python_version > "3.5"
 Provides-Extra: asyncio-subscribe
 Requires-Dist: websockets ; extra == 'asyncio-subscribe'
 Provides-Extra: bond
```

## Comparing `rqdatac-3.0.4.dist-info/RECORD` & `rqdatac-3.0.5.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,52 +1,52 @@
 rqdatac/__init__.py,sha256=a0HbcG9uHohaM-skdDcCD1aTqou4KFAa5d9PLuzmN6I,967
 rqdatac/__init__.pyi,sha256=TySe_FcaM6CGIilA8xLtq3cgN4b1QYYmUtr69TM6_bs,10668
 rqdatac/_internal.py,sha256=abdi2JnDfRvt4JDIArQJuAYAgdKEwHV8ZtRAuw_fOR8,934
-rqdatac/_version.py,sha256=2nMnekZQDTPgcK3IYJxQ2SZ3NdEcUGaLAENRELGmAeU,518
+rqdatac/_version.py,sha256=dnQwh_w0_ERhu1YF9S-J5Iwl0vRZ-1VJJsEylN88dP0,518
 rqdatac/client.py,sha256=pauqhPhvnY3bmWMMJ67e_DCqUdnWYL_s86lxTkGrStg,10387
-rqdatac/connection.cp39-win_amd64.pyd,sha256=xzaER0NVQaEGMiP7nPOxhK7p2eJdB6Jp6izMsEA-oGA,138752
+rqdatac/connection.cp39-win_amd64.pyd,sha256=pxNI5R0lJvm8W31yWyR5-AtRUoh1UUAbm4MmaTy5NgY,138752
 rqdatac/connection.cpp,sha256=tuZ22Ao7Nv4AJrfnw4W7Ni3Gv7jzRdxBkkiQ1ln_ufU,760728
 rqdatac/connection_pool.py,sha256=--mQnkbEFk0BbSsGpiHZKrijyut0niR4OsqGaR2-Y2U,2239
 rqdatac/decorators.py,sha256=cEGPnC2AlXHtt9Vsdxv7324beivEEYjMIFjv51EWZU0,4447
 rqdatac/rqdatah_helper.py,sha256=MmWLVsZ5ZiXcgs_cSeztZ2SL5F6R-bkh-f9LNBZiZMw,3072
 rqdatac/thread_local.py,sha256=ywvXoXa1L4LtFyAFBtEZGvkjvbPQFI-7Gb3mhxZXld8,2140
-rqdatac/utils.py,sha256=rNrDHJaWyeVbV5I707u1OZsT4u0tkZ5gzXIXdFqtD9Q,8727
+rqdatac/utils.py,sha256=y9cOK2STswXy9eC-9309UKde7svzni1Jeoz_BtA-i2I,10929
 rqdatac/validators.py,sha256=lN3S7GXjJ-TLzfhVqj1UgEtcyK9Sm2E4uMoySFVWhzA,9265
 rqdatac/services/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 rqdatac/services/async_live_md_client.py,sha256=r3wOAAYAZ-tiVmOo6gVJHa9TJ-7762zO5suHlRLDg4k,6792
 rqdatac/services/basic.py,sha256=gIZU51IFvJQ7Xm_pG_vfrXhy982nockJ1M-HoSzK82Y,74860
 rqdatac/services/calendar.py,sha256=_AI5pkoJasPJ8qCh3RcMjg7RqzuUw-BVgy9gnjXBEs8,6202
 rqdatac/services/concept.py,sha256=l7dGWo6sMsnlyKQClRkMcaxlxOcIX7PoucvgV5MwBhI,2470
 rqdatac/services/consensus.py,sha256=N157k0uWkOowqcqgcX_KqV7BNYGbXFCRduNp267VaSY,47501
 rqdatac/services/constant.py,sha256=IbnKoILR2wXLoqcVJlFJdtMOnHzYhC2i06qfjPkSeCs,10141
 rqdatac/services/convertible.py,sha256=z_-2QrrqFQCz08OKjMgBATjkTKlevn7MDoLe7jv9oA8,29339
 rqdatac/services/extra.py,sha256=MXt5zBsRGitRIpDrT_IzLrIhAPnb99l-Wv7gXL90WZE,2405
 rqdatac/services/factor.py,sha256=TQCaP1LgQT6ZZvMZdopSfrU9993wBspB5kblwsRnXzY,33958
-rqdatac/services/financial.py,sha256=886ciBUDYMR3H79qCOuIkW_TvGV40rifCvCsX0Ar-rU,12600
+rqdatac/services/financial.py,sha256=5gr9K2KjnOE1gkw3gAfVly3TGA20vYYp6BTLdJGIfJc,12561
 rqdatac/services/future.py,sha256=DTfSAdCbaPMnMyz52UrPHJc_O6xOFnNSc58UrpwGNFE,33768
-rqdatac/services/get_capital_flow.py,sha256=8Pybf5G3Tg8saQmLr8R9GHGEjlgzOEaQbmNPLC1ON5s,15558
+rqdatac/services/get_capital_flow.py,sha256=zDPF2hgN0u43bv88nn5rszKNY1yjHImmi6Q0x3lBA7c,13532
 rqdatac/services/get_price.py,sha256=wk6zEvMioQmT6RryKTScWj5yAJVK6y5_qFJcCOUftK0,29756
 rqdatac/services/index.py,sha256=n_bXgktyxqE2RmXgjsxOM4lhzDyF1VbqZ7scDH9bvAI,8880
-rqdatac/services/ksh_auction_info.py,sha256=pR129bTBXrWj7PoQkMByNY2lEZvY4ZIag8M4-dqjeKg,8488
+rqdatac/services/ksh_auction_info.py,sha256=BAHp6f5DfuO3qwyylLWU6UO5ZW4ZARQuGPAXowpVJbI,6473
 rqdatac/services/live.py,sha256=fN2htMMevo8G7oxKU7xSUTLktcafEN2jgPSs4McbXGY,15816
 rqdatac/services/live_md_client.py,sha256=ZFH826cpE8Fq0nrld1_1ue29wNyz2TL6WriAM34puHI,17180
 rqdatac/services/market_data.py,sha256=1ZJN7c3q5Gh9U5tbevDAY4T9ftI8SHTt1Vmt9y_o-2w,18853
-rqdatac/services/options.py,sha256=f0QTOPLvw9hMsn4gRrOtQgN8TuQ7KZ1RV3DuWHOysF8,11873
+rqdatac/services/options.py,sha256=0bEwy6Phv6riliwmoRlboLUQO6mzBM2PDTlkDxAqB9k,12650
 rqdatac/services/shenwan.py,sha256=42LrrMfy8F20OgcdSxRcP62p6MHEMjl0Hq-LGKtmHRI,9995
 rqdatac/services/stock_status.py,sha256=1eJJOCeDeMnsTmQRWKGYjjO-EvxU2r7HTePgExp9Oi0,29976
 rqdatac/services/structured_fund.py,sha256=EuHPDy4x0yEhsa8UFmPquRkPYehT7vFMUdfStoCXH78,2310
 rqdatac/services/tmall.py,sha256=xnguR3EtsUgS2pOhuKSIntuYMD5Av0RQ43-o928E6oU,2268
 rqdatac/services/xueqiu.py,sha256=05EjY0arr3czJqcSW7eUaUNHLCg_oR-Op1dz2FnJAlY,3649
 rqdatac/services/detail/__init__.py,sha256=km3ukXA_kKk738F7IUc_8mjfC8xys_k0X7O4U1yu6KU,61
 rqdatac/services/detail/adjust_price.py,sha256=h96rZdV4BkUzXF6hfIz9fT1CBcJF5uCnFcXIbbK2hOg,5733
-rqdatac/services/detail/get_price_df.py,sha256=z2wcJJfi7R2iyp4EroSWXwAYvHobfSzWpgy3-2LO0C4,15968
+rqdatac/services/detail/get_price_df.py,sha256=cQP2kq3wQEVthbszUsz5O65UQUgOLslyI0zo0_5qxXY,14077
 rqdatac/services/detail/resample_helper.py,sha256=EjcyKO3l4exvS8i8DAre6NdlrX27o4m0k8lHFgd8C6c,1833
 rqdatac/services/orm/__init__.py,sha256=ely2PttjgSv7vKdzskuD1rtK_l_UOpmxJSz8isrveD0,16
 rqdatac/services/orm/pit_financials_ex.py,sha256=igBoSVTivx7AT8ogsDlI8rl7kLHg3VE62AoXGRbaUtw,12814
 rqdatac/share/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 rqdatac/share/codec.py,sha256=KYSRcPif3xqXzKVkiXxBwesLuA0THBmuOhBmudKpe3k,5289
 rqdatac/share/errors.py,sha256=BBBnwcxoSRRnxDfGPCBF9UNh0mEe2AI6PISjlBWnSg4,1728
 rqdatac/share/protocol.py,sha256=Gmx2kC04hfqZhsy6EqmxM_y_UWu6k7B9TCRpHzMpP5o,1817
-rqdatac-3.0.4.dist-info/METADATA,sha256=wwZjV_vyOf_irfpalsFUwsx9549SwDoxcqzuH135Sf4,2540
-rqdatac-3.0.4.dist-info/WHEEL,sha256=jr7ubY0Lkz_yXH9FfFe9PTtLhGOsf62dZkNvTYrJINE,100
-rqdatac-3.0.4.dist-info/top_level.txt,sha256=I8Iv5zqeIYph4_6GREZAPsFzfVvodVwdc-ZHdtjJWCY,8
-rqdatac-3.0.4.dist-info/RECORD,,
+rqdatac-3.0.5.dist-info/METADATA,sha256=LWrT_v_7o1LZ2psTPBkLI8lFaTb-DuN_nkjLfpXtrJM,2517
+rqdatac-3.0.5.dist-info/WHEEL,sha256=jr7ubY0Lkz_yXH9FfFe9PTtLhGOsf62dZkNvTYrJINE,100
+rqdatac-3.0.5.dist-info/top_level.txt,sha256=I8Iv5zqeIYph4_6GREZAPsFzfVvodVwdc-ZHdtjJWCY,8
+rqdatac-3.0.5.dist-info/RECORD,,
```

